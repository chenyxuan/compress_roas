The interface script (PyPrefix)

# create a new Trie (class: IPSortedStringTrie) that uses the below function to have dictionary as input.
# count how many prefix's you have in the Trie.
# run the minimizing function to minimize the Trie.
# count the new number of prefix's in the Trie.
# calculate the difference and print the results.


# function that reads files (txt,CSV or even string input) and returns a dictionary that you can use to create a Trie.
    # declare an empty dictionary to add keys to
    # for each line in the file
        # Get the Time,AS,prefix and maxLength (if exists)
            # If max_length is not provided, create on that equals the prefix length.
        # create a binary key in this format ( '$' (to create a single root for the Trie) + version of IP {4,6} (to create sepreate sub-Tries for each version)
		#										+ binary representation of AS number + '?' (to avoid duplicates with an AS + prefix that matches another one)
		#										+ binary representation of the prefix ).
        # create a dictionary object using the data we have as follows: {key: [Time, AS, prefix, maxLength]}
        # check if key already exists in the Trie:
            # if True, (same AS and prefix), check if the max_length of the prefix from this ROA is higher than the one already stored, replace with the max of both.
        # else: update the dictionary with this new object.

    # when done, return the dictionary with all the objects in it.




-----------------------------------------------------------------------------------------------------------------------
The class script (IPSortedTrie)

# edit the node class from the PyTrie to:
    # Add a new attribute "show" to detrmine if a node is allowed to be printed and showed as a part of the Trie

# edit the Trie class from the PyTrie to:
    # use the new node I created to store objects.
    # when iterating over items to print, only print the items in which node.show is TRUE.
	
    # the minimization algorithm:
        # start from the root of the Trie.
        # go recursivly using DFS till the end (leafs) of the Trie (when a node have 0 children).
        # when on your way back from the bottom:
            # check if two children exists for the node (parent), else do nothing:
                # if True, check that the children are valid nodes that hold value in them (not just nodes to connect the other nodes).
                    # if True, check if the node's max length is >= to the max of children's max length:
                        # if True, skip the next step.
                    # change the node's max length to the minimum of chilren's max length.
                    # check if the node's new (or same in case the above condition was True) max length is >= to the first child's max length:
                        # if True, change first_child.show to be False.
                    # check if the node's new (or same) max length is >= to the second child's max length:
                        # if True, change second_child.show to be False.
