#! /usr/bin/python

import os
import argparse
from pytrie import NULL, SortedStringTrie as Trie
import netaddr
import subprocess


def getROA(output):
    '''
    Input: a list of ROAs as an input and extracts the data (prefix,AS,maxLength)
    Output: a dictionary with a Trie of prefixes for each unique AS in the ROAs.
    '''
    Trie_dict = dict()
    output = output.split('\n')
    for line in output:
        line = line.replace('\n', "").split(' ')
        Time = line[0]  # Signing time of ROA.
        AS = line[1]  # AS number
        IP = line[2:]  # Prefixes with '/prefixLength'
        for ip in IP:
            # In the case of multiple prefixes
            ip = ip.split('-')  # To get the maxLength if it's there
            prefix = ip[0]
            prefixLength = netaddr.IPNetwork(prefix).prefixlen

            try:
                # check if the maxLength exists.
                maxLength = int(ip[1])
                if maxLength < prefixLength:
                    # If maxLength is shorter than prefixLength, skip this
                    # prefix.
                    continue
            except IndexError:
                # If maxLength doesn't exist, set maxLength to prefixLength.
                maxLength = prefixLength

            # Generate the key to be used to insert into the Trie
            key = prefix_to_key(prefix)

            if AS in Trie_dict:
                if key in Trie_dict[AS]:
                    Trie_dict[AS][key][3] = max(
                        maxLength, Trie_dict[AS][key][3])
                else:
                    Trie_dict[AS][key] = [Time, AS, prefix, maxLength]
            else:
                Trie_dict[AS] = {key: [Time, AS, prefix, maxLength]}
    return Trie_dict

def prefix_to_key(prefix):
    ''' A function given a prefix generates a binary key to be used in a Trie.'''
    prefix = netaddr.IPNetwork(prefix)
    address = prefix.ip.bits().replace(".", "").replace(":", "")
    l = int(prefix.cidr.hostmask.bin, 2)
    while(l > 0):
        address = address[:-1]
        l >>= 1

    # Building the key
    key = str(prefix.version) + '$'
    key += address
    return key

def compress(AS, mDict):
    _t = Trie(**mDict[AS])

    def compress_Tries(node):
        ''' This function compresses the prefix's '''
        if node is None or (not node.children):
            # When you reach a leaf node, just stop.
            return

        g = node.children.iteritems()

        # To get pointers on the children nodes.
        fchild = node.children.get(str(g.next()[0]))
        try:
            schild = node.children.get(str(g.next()[0]))
        # in case a second child doesn't exist.
        except StopIteration:
            schild = None

        # The recursive call to reach the end of the Trie.
        compress_Tries(fchild)
        compress_Tries(schild)

        # Check if the node is an prefix (not just a connecting node) and
        # that 2 children exist with prefix's and value's
        if node.value is not NULL and fchild.value is not NULL and schild is not None and schild.value is not NULL:
            # To check if the maxLength of the parent is higher or equal to
            # the max(children's  maxLength)
            if node.value[2] >= maxML([fchild, schild]):
                pass  # No need to change the maxLength in this case.
            else:
                # Only update the max length of the parent if it's less
                # than the max of children
                node.value[2] = minML([fchild, schild])
            # Only hide a child if the parent's max length is covering the child's max length
            if node.value[2] >= fchild.value[2]:
                key = mf.prefix_to_key(netaddr.IPNetwork(fchild.value[1]))
                del Trie[key]
            # Only hide a child if the parent's max length is covering the
            # child's max length
            if node.value[2] >= schild.value[2]:
                key = mf.prefix_to_key(netaddr.IPNetwork(schild.value[1]))
                del Trie[key]

    compress_Tries(_t._root)
    mDict[AS] = dict(_t)

def print_dict(Dict):
    ''' Print all the data '''
    for AS in Dict.values():
        for prefix in AS.values():
            prefix_str = str(prefix[0]) + ' ' + str(prefix[1]) + \
                ' ' + str(prefix[2]) + '-' + str(prefix[3])
            print(prefix_str)

def main():

    # Call "scan_roas" to get the list of ROAs.
    args = 'sudo -H -u rpki scan_roas'
    terminal = subprocess.Popen(
        [args.split(' '), roaDumpPath], stdout=subprocess.PIPE)
    output = terminal.communicate()[0]

    # Generate the dictionary of Tries.
    Trie_dict = getROA(output)

    # Compress the data in the dictionary.
    [compress(AS, Trie_dict) for AS in Trie_dict.keys()]

    print_dict(Trie_dict)



if __name__ == "__main__":
    main()
